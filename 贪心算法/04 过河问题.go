/*
过河问题
时间限制：1000 ms  |  内存限制：65535 KB
难度：5
描述
在漆黑的夜里，N位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。不幸的是，N个人一共只带了一只手电筒，而桥窄得只够让两个人同时过。如果各自单独过桥的话，N人所需要的时间已知；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间。问题是，如何设计一个方案，让这N人尽快过桥。

输入
第一行是一个整数T(1<=T<=20)表示测试数据的组数
每组测试数据的第一行是一个整数N(1<=N<=1000)表示共有N个人要过河
每组测试数据的第二行是N个整数Si,表示此人过河所需要花时间。(0<Si<=100)
输出
输出所有人都过河需要用的最少时间
样例输入
1
4
1 2 5 10
样例输出
17
 */
 /*
 分析：
 当n = 1 || n = 2时，时间为最长的那个
 当n = 3时，(1)最短时间的人和其中一个人过去，然后最短时间的人回来，之后剩下的两个人过去
 当m >= 4时，有两种可能是最优情况
	第一种：每次都是最短的回来，a[0],a[1],a[n-2],a[-1]，总时间x1 = a[0] * 2 + a[1] + a[n-2] + a[n-1]
 	第二种：最短和次短的分别回来，a[0],a[1],a[n-2],a[-1]，总时间x2 = a[0] + a[2] * 3 + a[n-1]
 	a[1]+a[0]+a[n-1]+a[2]

 	x1 - x2 = a[0] - a[2] * 2 +a[n-2]
 	当x1 = x2，a[0] + a[n-2] = a[2] * 2		(如：1+3=2*2)
 	当x1 > x2，a[0] + a[n-2] > a[2] * 2		(如：1+6>2*2)
 	当x1 < x2，a[0] + a[n-2] < a[2] * 2		(如：1+4<3*2)

 现在每次将最慢的两个送过去：
 	1）a[0] * 2 + a[n-2] + a[n-1]
 	2）a[0] + a[1] * 2 + a[n-1]
  */
package main

import (
	"fmt"
	"math"
)

func main() {
	var T, N, tT, tempT int
	fmt.Scan(&T)
	for i := 0;i < T;i++ {
		fmt.Scan(&N)
		si := make([]int, 0, N)
		for i := 0;i < N;i++ {
			fmt.Scan(&tempT)
			si = append(si, tempT)
		}
		length := len(si)
		tT = 0
		for length > 3 {
			minT := math.Min(float64(si[0] * 2 + si[length-2] + si[length-1]), float64(si[0] + si[1] * 2 + si[length-1]))
			tT += int(minT)
			length -= 2
		}
		if length == 2 {
			tT += si[1]
		} else {
			tT += si[0] + si[1] + si[2]
		}
		fmt.Println(tT)
	}
}